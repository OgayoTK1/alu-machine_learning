#!/usr/bin/env python3
"""
8. Put it all together and what do you get?

Mandatory task combining partial derivatives into the full gradient.

The gradient ∇f of a multivariable function f(x₁, x₂, ..., xₙ) is the vector
that "puts it all together":

∇f = (∂f/∂x₁, ∂f/∂x₂, ..., ∂f/∂xₙ)

It collects all partial derivatives into a single vector that points in the
direction of steepest ascent and whose magnitude is the rate of change in
that direction. In machine learning, the gradient is central to optimization
algorithms like gradient descent.

This module provides two numerical methods to approximate the gradient of a
function f at a point (given as a list or tuple of floats):

- forward_gradient: Simple forward difference (n + 1 function evaluations)
- central_gradient: Central difference (2n function evaluations, higher accuracy)
"""

def forward_gradient(f, point, h=1e-5):
    """
    Approximate the gradient of f at 'point' using forward differences.

    Args:
        f (callable): Function taking a sequence of floats and returning a float.
        point (list or tuple): Point (x₁, x₂, ...) at which to evaluate.
        h (float, optional): Step size. Default 1e-5.

    Returns:
        list: Approximation of ∇f(point) as a list of floats.
    """
    point = list(point)
    n = len(point)
    f0 = f(point)
    grad = [0.0] * n
    for i in range(n):
        original = point[i]
        point[i] += h
        grad[i] = (f(point) - f0) / h
        point[i] = original
    return grad


def central_gradient(f, point, h=1e-7):
    """
    Approximate the gradient of f at 'point' using central differences
    (more accurate than forward difference).

    Args:
        f (callable): Function taking a sequence of floats and returning a float.
        point (list or tuple): Point (x₁, x₂, ...) at which to evaluate.
        h (float, optional): Step size. Default 1e-7.

    Returns:
        list: Approximation of ∇f(point) as a list of floats.
    """
    point = list(point)
    n = len(point)
    grad = [0.0] * n
    for i in range(n):
        original = point[i]
        point[i] = original + h
        f_plus = f(point)
        point[i] = original - h
        f_minus = f(point)
        point[i] = original
        grad[i] = (f_plus - f_minus) / (2 * h)
    return grad
